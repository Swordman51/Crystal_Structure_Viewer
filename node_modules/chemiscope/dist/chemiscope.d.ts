// Generated by dts-bundle-generator v7.2.0

/**
 * @packageDocumentation
 * @module main
 */
/** A dataset containing all the data to be displayed. */
export interface Dataset {
	/** metadata for this dataset */
	meta: Metadata;
	/**
	 * List of structures in the dataset.
	 *
	 * The structures can either follow the `Structure` interface, in which
	 * case they will be loaded as-defined; or contain any kind of data as a
	 * {@link UserStructure}, in which case the {@link ViewersGrid.loadStructure}
	 * callback should be set to translate from whatever is stored to a
	 * {@link Structure}.
	 */
	structures: Structure[] | UserStructure[];
	/**
	 * List of properties for the structures (`target == "structure"`), or
	 * atom-centered environments in the structures (`target == "atom"`).
	 *
	 * For structure properties, the `values` array of the property should have
	 * the same size as the structure list in `Dataset.structures`.
	 *
	 * For atomic properties, the `values` array of the property should have
	 * the same size as the environments list in `Dataset.environments`.
	 */
	properties: {
		[name: string]: Property;
	};
	/**
	 * List of atom-centered environments in the dataset.
	 *
	 * Currently, the code assumes that every atom is associated with an
	 * environment. This may change in the future.
	 */
	environments?: Environment[];
	/** Settings for visualization of this dataset */
	settings?: Partial<Settings>;
}
/**
 * Type definition for settings that can be saved with a dataset. THey should be
 * a simple object with string keys, scalar values, array values or nested
 * Settings objects.
 */
export interface Settings extends Record<string, string | string[] | number | number[] | boolean | boolean[] | Settings | Settings[]> {
}
/** Various metadata associated with a dataset */
export interface Metadata {
	/** dataset name */
	name: string;
	/** authors of the dataset */
	authors?: string[];
	/** academic references related to this dataset */
	references?: string[];
	/** description of the dataset */
	description?: string;
}
/** A single atomic structure */
export interface Structure {
	/** Number of atoms in the structure */
	size: number;
	/** Names of all atoms in the structure */
	names: string[];
	/**
	 * x position (cartesian coordinate) of all atoms in the structure
	 *
	 * This array should have the same size as {@link Structure.names}, and contain
	 * values expressed in Angströms.
	 */
	x: number[];
	/**
	 * y position (cartesian coordinate) of all atoms in the structure
	 *
	 * This array should have the same size as {@link Structure.names}, and contain
	 * values expressed in Angströms.
	 */
	y: number[];
	/**
	 * z position (cartesian coordinate) of all atoms in the structure
	 *
	 * This array should have the same size as {@link Structure.names}, and contain
	 * values expressed in Angströms.
	 */
	z: number[];
	/**
	 * Unit cell of the system, given as `[ax ay az bx by bz cx cy cz]`, where
	 * **a**, **b**, and **c** are the unit cell vectors. All values should be
	 * expressed in Angströms.
	 */
	cell?: number[];
}
/**
 * User-defined data to allow dynamic loading of the structures.
 *
 * The main use-case of this is making the initial loading time of chemiscope
 * faster by loading structure on-demand, from files, a database or even a
 * javascript program.
 */
export interface UserStructure {
	/** Number of atoms in the structure */
	size: number;
	/**
	 * User-defined data which can be turned into a {@link Structure}.
	 *
	 * {@link ViewersGrid.loadStructure} must be set to be able to load this
	 * data.
	 */
	data: unknown;
}
/** Possible types of properties: full structure property, or atomic property */
export type Target = "structure" | "atom";
/**
 * A single property in a dataset.
 *
 * Properties can be physical properties (energy, number of atoms, density,
 * *etc.*); values associated with the structure (such as SOAP vectors),
 * projected onto a lower dimensionality sub-space (through PCA or any other
 * algorithm); or any other value associated with every structure/environment in
 * the dataset.
 */
export interface Property {
	/** is this property associated with a full structure or a single atom? */
	target: Target;
	/**
	 * values of the property
	 *
	 * string values should represent classification results (category "A", "B"
	 * or "C"); and numeric values should be use for everything else.
	 */
	values: string[] | number[];
	/** user-facing description of the property */
	description?: string;
	/** unit of the property values */
	units?: string;
}
/**
 * An atom-centered environment.
 *
 * Currently, only spherical (i.e. cutoff-based) environments are supported
 */
export interface Environment {
	/** Index of the related structure in {@link Dataset.structures} */
	structure: number;
	/** Index of the central atom in the structure, 0-based */
	center: number;
	/** Spherical cutoff radius, expressed in Angströms */
	cutoff: number;
}
/**
 * If a dataset contains both atomic and structure properties, we can only
 * display one kind at the time, indicated by the {@link DisplayMode}.
 */
export type DisplayMode = "structure" | "atom";
/**
 * Indexes related to a single entry in a property.
 *
 * This can exists in either structure mode (in which case `environnement ===
 * structure` and atom is undefined); or atom mode. In atom mode, the
 * environnement is the index of the entry in the property, and structure/atom
 * define to which atom in which structure the entry correspond.
 */
export interface Indexes {
	/** The global environment index. */
	environment: number;
	/**
	 * Index of the structure which this `Indexes.environment` corresponds to.
	 */
	structure: number;
	/**
	 * Index of the atom in the structure which corresponds to the environment.
	 *
	 * If we are considering structures properties, this is `undefined`.
	 */
	atom?: number;
}
/**
 * {@link EnvironmentIndexer} links environment index and structure/atom indexes
 *
 * Environments can be either full structures or centered on a specific atom.
 * This class makes the link between two representations: a single, global,
 * environment index, used by the map; and the structure/atom pair, used by
 * the structure viewer and the general information panel.
 */
export declare class EnvironmentIndexer {
	/**
	 * Current {@link DisplayMode}. This is useful for datasets that
	 * contain both atom-level and structure-level properties.
	 */
	mode: DisplayMode;
	private _structures;
	private _environments?;
	private _activeStructures;
	private _activeAtoms;
	/**
	 * Create a new {@link EnvironmentIndexer} for the given set of structures and
	 * environments.
	 *
	 * @param mode         should we display atomic or structure properties
	 * @param structures   structures used in the current dataset
	 * @param environments environments used in the current dataset
	 */
	constructor(mode: DisplayMode, structures: Structure[] | UserStructure[], environments?: Environment[]);
	/**
	 * Get a full set of indexes from the global environment index
	 * @param  environment global index of an environment
	 * @return             full {@link Indexes}, containing the corresponding
	 *                     structure / atom indexes
	 */
	from_environment(environment: number): Indexes;
	/**
	 * Get a full set of indexes from the structure/atom indexes
	 * @param  structure index of the structure in the full structure list
	 * @param  atom      index of the atom in the structure
	 * @return an {@link Indexes} instance, containing the global environment index;
	 *         or ``undefined`` if there is no environment corresponding to the
	 *         given atom in the given structure
	 */
	from_structure_atom(structure: number, atom?: number): Indexes | undefined;
	/** Does this Indexer knows about atom-centered environments? */
	hasEnvironments(): boolean;
	/** Get the total number of structures we know about */
	structuresCount(): number;
	/** Get the total number of atom in the `structure` with given index */
	atomsCount(structure: number): number;
	/** Get the indexes of structure containing at least one atoms in the set
	 * of active environments for this `structure` */
	activeStructures(): number[];
	/** Get the indexes of atoms actually part of the environments for this `structure` */
	activeAtoms(structure: number): number[];
}
/**
 * The {@link EnvironmentInfo} class displays information about structure or
 * environment, using a slider for selection and an hidden by default table
 * displaying all properties.
 */
export declare class EnvironmentInfo {
	/** Callback used when the user changes one of the sliders value */
	onchange: (indexes: Indexes) => void;
	/** delay in ms between "frames" during playback over structures/atoms */
	playbackDelay: number;
	private _shadow;
	private _root;
	private _atom?;
	private _structure;
	private _indexer;
	/**
	 * Create a new {@link EnvironmentInfo} inside the DOM element with given `id`
	 * @param element    HTML element or string 'id' of the element where
	 *                   the sliders and tables should live
	 * @param properties properties to be displayed
	 * @param indexer    {@link EnvironmentIndexer} used to translate indexes from
	 *                   environments index to structure/atom indexes
	 * @param viewer     {@link ViewersGrid} from which we get the playback delay
	 */
	constructor(element: string | HTMLElement, properties: {
		[name: string]: Property;
	}, indexer: EnvironmentIndexer);
	/** Show properties for the given `indexes`, and update the sliders values */
	show(indexes: Indexes): void;
	/**
	 * Remove all HTML added by this {@link EnvironmentInfo} in the current document
	 */
	remove(): void;
	/** Create the structure slider and table */
	private _createStructure;
	/** Create the atom slider and table */
	private _createAtom;
	/** Get the currently selected structure/atom/environment */
	private _indexes;
}
/**
 * @packageDocumentation
 * @module utils
 */
/** A {@link WarningHandler} is called when a new warning is emitted */
export type WarningHandler = (message: string) => void;
/** Register the `handler` function to be called when a warning is emitted */
export declare function addWarningHandler(handler: WarningHandler): void;
/** Callback type to position an HTML element.
 *
 * The callback gets the current placement of the settings as a
 * [DOMRect](https://developer.mozilla.org/en-US/docs/Web/API/DOMRect), and
 * should return top and left positions in pixels, used with `position:
 * fixed`.
 */
export type PositioningCallback = (rect: DOMRect) => {
	top: number;
	left: number;
};
declare const tag: unique symbol;
export type GUID = string & {
	readonly [tag]: "guid";
};
/**
 * The {@link PropertiesMap} class displays a 2D or 3D map (scatter plot) of
 * properties in the dataset, using [plotly.js](https://plot.ly/javascript/)
 * for rendering.
 *
 * Properties can be used as x, y, or z values, as well as points color and
 * size. Additionally, string properties can be used as symbols for the scatter
 * plot markers.
 */
export declare class PropertiesMap {
	/** Callback fired when the plot is clicked and the position of the active marker changes */
	onselect: (indexes: Indexes) => void;
	/**
	 * Callback fired when the active marker is changed by clicking on the map
	 *
	 * @param guid GUID of the new active marker
	 * @param indexes index of the environment the new active marker is showing
	 */
	activeChanged: (guid: GUID, indexes: Indexes) => void;
	/**
	 * Callback to get the initial positioning of the settings modal.
	 *
	 * The callback gets the current placement of the settings as a
	 * [DOMRect](https://developer.mozilla.org/en-US/docs/Web/API/DOMRect), and
	 * should return top and left positions in pixels, used with `position:
	 * fixed`. The callback is called once, the first time the settings are
	 * opened.
	 */
	positionSettingsModal: PositioningCallback;
	private _shadow;
	private _root;
	private _plot;
	private _data;
	private _active?;
	private _selected;
	private _indexer;
	private _options;
	private _colorReset;
	private _plotFix;
	/**
	 * Create a new {@link PropertiesMap} inside the DOM element with the given HTML
	 * `id`
	 *
	 * @param element   HTML element or string 'id' of the element where
	 *                   the map should live
	 * @param indexer    {@link EnvironmentIndexer} used to translate indexes from
	 *                   environments index to structure/atom indexes
	 * @param properties properties to be displayed
	 */
	constructor(config: {
		element: string | HTMLElement;
		settings: Settings;
	}, indexer: EnvironmentIndexer, properties: {
		[name: string]: Property;
	});
	/**
	 * Remove all HTML added by this {@link PropertiesMap} in the current document
	 */
	remove(): void;
	/**
	 * Change the environment indicated by the currently active marker to
	 * the one with the given `indexes`
	 */
	select(indexes: Indexes): void;
	/**
	 * Set the marker with given GUID as the active marker.
	 *
	 * @param guid the GUID of the new active viewer
	 */
	setActive(guid: GUID): void;
	/**
	 * Add a new marker to the map. The new marker is set as the active one
	 *
	 * @param guid GUID of the new marker
	 * @param indexes indexes of the environment that the new marker should show
	 */
	addMarker(guid: GUID, color: string, indexes: Indexes): void;
	/**
	 * Removes a marker from the map.
	 *
	 * @param guid GUID of the marker to remove
	 */
	removeMarker(guid: GUID): void;
	/**
	 * Apply saved settings to the map.
	 */
	applySettings(settings: Settings): void;
	/**
	 * Save the values of the current settings in a way that an be used with
	 * {@link applySettings} or saved to JSON.
	 */
	saveSettings(): Settings;
	/**
	 * Add the given `callback` to be called whenever a setting changes. The
	 * callback will be given the path to the settings as a list of keys; and
	 * the new value of the setting.
	 *
	 * There is currently no way to remove a callback.
	 */
	onSettingChange(callback: (keys: string[], value: unknown) => void): void;
	/** Forward to Plotly.restyle */
	private _restyle;
	/** Forward to Plotly.relayout */
	private _relayout;
	/** Add all the required callback to the settings */
	private _connectSettings;
	/** Actually create the Plotly plot */
	private _createPlot;
	/** Get the property with the given name */
	private _property;
	/**
	 * Get the values associated with the given `axis`, to use with the given
	 * plotly `trace`, or all of them if `trace === undefined`
	 *
	 * @param  axis   Options of the axis we need coordinates for
	 * @param  trace  plotly trace for which we require coordinate
	 * @return        data usable with Plotly.restyle
	 */
	private _coordinates;
	private _title;
	/**
	 * Get the color values to use with the given plotly `trace`, or all of
	 * them if `trace === undefined`
	 */
	private _colors;
	/**
	 * Get the **line** color values to use with the given plotly `trace`, or
	 * all of them if `trace === undefined`
	 */
	private _lineColors;
	/**
	 * Get the values to use as marker size with the given plotly `trace`, or
	 * all of them if `trace === undefined`.
	 */
	private _sizes;
	/**
	 * Get the values to use as marker symbol with the given plotly `trace`, or
	 * all of them if `trace === undefined`.
	 */
	private _symbols;
	/** Should we show the legend for the various symbols used? */
	private _showlegend;
	/** Get the list of symbols names to use for the legend */
	private _legendNames;
	/**
	 * Select either main, selected or both depending on `trace`, and return
	 * them in a mode usable with `Plotly.restyle`/{@link PropertiesMap._restyle}
	 */
	private _selectTrace;
	/** Get the length of the colorbar to accommodate for the legend */
	private _colorbarLen;
	/** Is the the current plot a 3D plot? */
	private _is3D;
	/** How many symbols are on this plot?*/
	private _symbolsCount;
	/** Switch current plot from 2D to 3D */
	private _switch3D;
	/** Switch current plot from 3D back to 2D */
	private _switch2D;
	/**
	 * Function used as callback to update the axis ranges in settings after
	 * the user changes zoom or range on the plot
	 */
	private _afterplot;
	/**
	 * Update the position, color & size of markers. If `markers` is present, only
	 * markers inside the array are updated, otherwise everything is updated.
	 */
	private _updateMarkers;
	private _getBounds;
	private _pixelCoordinate;
	/** Changes the step of the arrow buttons in min/max input based on dataset range*/
	private _setScaleStep;
}
/**
 * The {@link MetadataPanel} class displays information regarding the dataset: name,
 * authors, references, description, etc.
 *
 * By default, only the name is shown, and clicking on it reveals a modal with
 * the other information.
 */
export declare class MetadataPanel {
	private _shadow;
	private _name;
	private _modal;
	/**
	 * Create a new {@link MetadataPanel} inside the HTML element with the given
	 * `id`.
	 *
	 * @param element HTML element or HTML id of the DOM element where the name of the dataset should be inserted
	 * @param metadata dataset metadata
	 */
	constructor(element: string | HTMLElement, metadata: Metadata);
	/**
	 * Remove all HTML added by this {@link EnvironmentInfo} in the current document
	 */
	remove(): void;
}
/**
 * The {@link ViewersGrid} class displays a grid of molecule or a crystal viewers
 * in 3D using {@link MoleculeViewer} widgets for rendering.
 */
export declare class ViewersGrid {
	/** Callback used when the user select an environment */
	onselect: (indexes: Indexes) => void;
	/** Callback fired when a viewer is removed from the grid */
	onremove: (guid: GUID) => void;
	/**
	 * Callback fired when a new viewer is created
	 *
	 * @param guid GUID of the new viewer
	 * @param color GUID of the marker indicating the new viewer
	 * @param indexes environment showed in the new viewer
	 */
	oncreate: (guid: GUID, color: string, indexes: Indexes) => void;
	/**
	 * Callback fired when the active viewer is changed
	 *
	 * @param guid GUID of the new active viewer
	 * @param indexes environment showed in the new active viewer
	 */
	activeChanged: (guid: GUID, indexes: Indexes) => void;
	/**
	 * Callback fired when the playback delay for structure/atom playback changed
	 *
	 * @param delay the new delay value
	 */
	delayChanged: (delay: number) => void;
	/**
	 * Callback used when a new structure should be loaded
	 *
	 * By default, this assumes that the loaded dataset contains {@link Structure}
	 * directly, and returns the data from there. If the loaded dataset contains
	 * {@link UserStructure} instead, this callback should be set to transform from
	 * data in {@link UserStructure.data} to a {@link Structure}.
	 *
	 * The callback gets two parameter: the structure index (0-based); and the
	 * full {@link UserStructure}.
	 */
	loadStructure: (index: number, structure: unknown) => Structure;
	private _shadow;
	private _root;
	private _structures;
	private _resolvedStructures;
	private _environments?;
	private _maxViewers;
	private _indexer;
	private _active;
	private _viewers;
	private _positionSettingsModal?;
	private _onSettingChangeCallbacks;
	/**
	 * Create a new {@link ViewersGrid} inside the HTML element with the given
	 * `id`
	 *
	 * @param element      HTML element or string 'id' of the element where
	 *                     viewer should live
	 * @param indexer      {@link EnvironmentIndexer} used to translate indexes from
	 *                     environments index to structure/atom indexes
	 * @param structures   list of structure to display
	 * @param environments list of atom-centered environments in the structures,
	 *                     used to highlight the selected environment
	 * @param maxViewers   maximum number of allowed structure viewers
	 */
	constructor(element: string | HTMLElement, indexer: EnvironmentIndexer, structures: Structure[] | UserStructure[], environments?: Environment[], maxViewers?: number);
	private _getById;
	/**
	 * Get the current active viewer GUID
	 */
	get active(): GUID;
	/**
	 * Get the current list of environments showed inside the different viewer
	 */
	pinned(): Indexes[];
	/**
	 * Show a new structure, as identified by `indexes` in the active viewer.
	 *
	 * This will switch to the structure at index `indexes.structure`, and if
	 * environments where passed to the constructor and the current display
	 * mode is `'atom'`, highlight the atom-centered environment corresponding
	 * to `indexes.atom`.
	 *
	 * @param  indexes         structure / atom pair to display
	 */
	show(indexes: Indexes): void;
	/**
	 * Add a new empty viewer to the grid
	 *
	 * @return the GUID and color of the new viewer, the GUID is `undefined`
	 *         if we already reached the viewer limit.
	 */
	addViewer(): {
		guid?: GUID;
		color: string;
	};
	/**
	 * Removes the viewer with the given `guid` from the viewer grid.
	 *
	 * @param guid GUID of the viewer to remove
	 */
	removeViewer(guid: GUID): void;
	/**
	 * Remove all HTML added by this {@link ViewersGrid} in the current document
	 */
	remove(): void;
	/**
	 * Function to set the active widget for communicating with the map
	 */
	setActive(guid: GUID): void;
	/**
	 * Set a callback to get the initial positioning of the settings modal of
	 * the viewers. The same callback is used for all viewers in the grid.
	 *
	 * The callback gets the current placement of the settings as a
	 * [DOMRect](https://developer.mozilla.org/en-US/docs/Web/API/DOMRect), and
	 * should return top and left positions in pixels, used with `position:
	 * fixed`. The callback is called once, the first time the settings are
	 * opened.
	 */
	set positionSettingsModal(value: PositioningCallback);
	/**
	 * Apply the given saved setting to all viewers in the grid.
	 *
	 * The settings must be in viewer creation order.
	 *
	 * @param settings settings for all viewers in the grid
	 */
	applySettings(settings: Settings[]): void;
	/**
	 * Get the current values of settings for all viewers in the grid.
	 *
	 * The settings are given in viewer creation order.
	 *
	 * @return the settings in an array, suitable to be used with {@link applySettings}
	 */
	saveSettings(): Settings[];
	/**
	 * Add the given `callback` to be called whenever a setting changes. The
	 * callback will be given the path to the settings as a list of keys; and
	 * the new value of the setting.
	 *
	 * There is currently no way to remove a callback.
	 */
	onSettingChange(callback: (keys: string[], value: unknown) => void): void;
	/**
	 * Add a new structure viewer to the grid as a copy of the viewer with the
	 * `initial` GUID. The new structure viewer is set as the active one.
	 *
	 * @param  initial GUID of the viewer to duplicate
	 * @return the GUID of the new viewer, or `undefined` if we already
	 *         reached the viewer limit.
	 */
	private _duplicate;
	/**
	 * Get the structure at the given index, potentially loading them using a
	 * user provided loading function.
	 *
	 * @param  index index of the structure
	 * @return       a Structure instance
	 */
	private _structure;
	private _showInViewer;
	/**
	 * Get an unused color to identify a viewer
	 *
	 * @return a CSS compatible color name
	 */
	private _getNextColor;
	/**
	 * Function to setup the cell in the structure viewer grid.
	 * Will generate a GUID string if one does not exist for the cell
	 * and instantiate all necessary buttons.
	 */
	private _setupCell;
	/**
	 * Function to initialize the grid instance for `this._nwidgets` cells and
	 * place onto the DOM element mapped in `this._root`. If more cells are
	 * needed, this function return the list of new cell GUID
	 */
	private _setupGrid;
	/**
	 * Function to return *optimal* arrangement of n widgets.
	 */
	private bestGridArrangement;
	/** get the current position in the viewer grid of a viewer by GUID */
	private _getCurrentPositionInGrid;
}
declare class Modal {
	private _element;
	private _activeElement;
	private _backdrop;
	private _open;
	shadow: ShadowRoot;
	/**
	 * Create a Modal instance.
	 * @param _element The root element to use as a modal. It should have the
	 *  .modal class.
	 */
	constructor(_element: HTMLElement);
	close(): void;
	open(): void;
	toggle(value?: boolean): void;
	remove(): void;
}
/**
 * Possible HTML attributes to attach to a setting
 */
export type Attribute = "value" | "checked" | "innerText";
export interface OptionsTypeMap {
	string: [
		string
	];
	int: [
		number
	];
	number: [
		number
	];
	boolean: [
		boolean
	];
}
export type OptionsType = keyof OptionsTypeMap;
export type OptionsValue<T extends OptionsType> = OptionsTypeMap[T][0];
/** Possible origins of a option change: from JS code, or from DOM interaction */
export type OptionModificationOrigin = "JS" | "DOM";
declare class HTMLOption<T extends OptionsType> {
	/** the type of the value stored by this setting */
	readonly type: T;
	/** Callback to validate the new value before propagating changes. */
	validate: (value: OptionsValue<T>) => void;
	/** Additional callbacks to run whenever the setting value changes */
	onchange: Array<(value: OptionsValue<T>, origin: OptionModificationOrigin) => void>;
	private _value;
	private _boundList;
	private _previous_value;
	/**
	 * Create a new {@link HTMLOption} containing a value of the given type.
	 * Possible type/values combinations are described in the {@link OptionsTypeMap}
	 * interface.
	 *
	 * @param type  type of the setting
	 * @param value initial value of the setting
	 */
	constructor(type: T, value: OptionsValue<T>);
	/** Get the value of this setting */
	get value(): OptionsValue<T>;
	/** Set a new value for this setting */
	set value(v: OptionsValue<T>);
	/**
	 * Call all onchange callbacks & update the DOM representation after a
	 * change. This function is called automatically when using `.value = ...`
	 */
	changed(origin: OptionModificationOrigin): void;
	/** Reset to a previous value for this setting */
	reset(): void;
	/**
	 * Add a new HTML element to the list of synchronized element.
	 * `element.attribute` will be set to the setting value, and the setting
	 * value will be updated every time the 'change' event is sent.
	 *
	 * @param  element   HTML DOM element to watch for updates, or string id
	 *                   of such element
	 * @param  attribute attribute of the HTML element to use as value
	 */
	bind(element: HTMLElement | string, attribute: Attribute): void;
	/**
	 * Disable all HTML elements linked to this by setting the `disabled`
	 * attribute to `true` if it exists on the element. This should only
	 * disable HTMLInputElement.
	 */
	disable(): void;
	/**
	 * Enable all HTML elements linked to this by setting the `disabled`
	 * attribute to `false` if it exists on the element. This should only
	 * enable HTMLInputElement.
	 */
	enable(): void;
	/**
	 * Remove all HTML elements bound to this setting, and the associated event
	 * listeners.
	 */
	unbindAll(): void;
	private _update;
}
/**
 * Callback function to use with {@link OptionsGroup.foreachSetting}
 */
export type OptionsCallback = (keys: string[], setting: HTMLOption<any>) => void;
declare abstract class OptionsGroup {
	/**
	 * Save the current values of all HTMLOption properties of the class,
	 * including nested ones.
	 *
	 * Properties which name starts with an underscore are ignored.
	 *
	 * @return An object with the same structure as this class containing the
	 *         values of all settings.
	 */
	saveSettings(): Settings;
	/**
	 * Set values from `settings` to the {@link HTMLOption} properties of this class,
	 * matching the properties names.
	 *
	 * Properties starting with an underscore are ignored.
	 */
	applySettings(settings: Settings): void;
	/**
	 * Add the given `callback` to be called whenever a setting changes. The
	 * callback will be given the path to the settings as a list of keys; and
	 * the new value of the setting.
	 *
	 * There is currently no way to remove a callback.
	 */
	onSettingChange(callback: (keys: string[], value: unknown) => void): void;
	/**
	 * Call the given callback on each setting inside the given SettingGroup.
	 *
	 * Keys starting with an underscore character are ignored.
	 *
	 * @param settings group of settings
	 * @param callback callback operating on a single setting
	 */
	protected foreachOption(callback: OptionsCallback): void;
}
declare class StructureOptions extends OptionsGroup {
	bonds: HTMLOption<"boolean">;
	spaceFilling: HTMLOption<"boolean">;
	atomLabels: HTMLOption<"boolean">;
	unitCell: HTMLOption<"boolean">;
	supercell: [
		HTMLOption<"int">,
		HTMLOption<"int">,
		HTMLOption<"int">
	];
	rotation: HTMLOption<"boolean">;
	axes: HTMLOption<"string">;
	keepOrientation: HTMLOption<"boolean">;
	playbackDelay: HTMLOption<"number">;
	environments: {
		activated: HTMLOption<"boolean">;
		center: HTMLOption<"boolean">;
		cutoff: HTMLOption<"number">;
		bgStyle: HTMLOption<"string">;
		bgColor: HTMLOption<"string">;
	};
	private _modal;
	private _openModal;
	private _positionSettingsModal;
	constructor(root: HTMLElement, positionSettings: PositioningCallback);
	/** Get in a element in the modal from its id */
	getModalElement<T extends HTMLElement = HTMLElement>(id: string): T;
	/** Get the modal used for these settings */
	get modal(): Modal;
	/**
	 * Remove all HTML added by this {@link StructureSettings} in the current
	 * document
	 */
	remove(): void;
	/**
	 * Applies saved settings, possibly filling in with default values
	 */
	applySettings(settings: Settings): void;
	/**
	 * Create HTML needed for structure settings.
	 *
	 * The HTML elements are returned, not yet inserted in the document.
	 *
	 * @return the HTML element containing the setting modal, and the button to open the modal
	 */
	private _createSettingsHTML;
	/** Bind all options to the corresponding HTML elements */
	private _bind;
}
/** Possible options passed to `MoleculeViewer.load` */
export interface LoadOptions {
	/** Supercell to display (default: [1, 1, 1]) */
	supercell: [
		number,
		number,
		number
	];
	/** Should preserve we the current camera orientation (default: false) */
	keepOrientation: boolean;
	/** Are we loading a file part of a trajectory (default: false) */
	trajectory: boolean;
	/** List of atom-centered environments in the current structure, potentially
	 * undefined if the environnement is not part of the dataset.
	 * The `structure` field of `Environment` is ignored */
	environments: (Environment | undefined)[];
	/**
	 * Index of the environment to highlight, this is only considered if
	 * `environments` is set.
	 */
	highlight: number;
}
/** */
export declare class MoleculeViewer {
	/** callback called when a new atom is clicked on */
	onselect: (atom: number) => void;
	/**
	 * Callback to get the initial positioning of the settings modal.
	 *
	 * The callback is called once, the first time the settings are opened.
	 */
	positionSettingsModal: PositioningCallback;
	private _shadow;
	private _root;
	private _viewer;
	private _current?;
	private _highlighted?;
	private _axes?;
	_options: StructureOptions;
	private _initialSupercell?;
	private _resetEnvCutoff;
	private _resetSupercell;
	private _cellInfo;
	private _trajectoryOptions;
	private _styles;
	private _environments?;
	/**
	 * Create a new `MoleculeViewer` inside the HTML DOM element with the given `id`.
	 *
	 * @param element HTML element or HTML id of the DOM element
	 *                where the viewer will be created
	 */
	constructor(element: string | HTMLElement);
	/**
	 * Remove all HTML added by this {@link MoleculeViewer} in the current document
	 */
	remove(): void;
	/**
	 * Resize the 3Dmol viewer/canvas to the size of the HTML element containing
	 * this widget.
	 */
	resize(): void;
	/**
	 * Get the number of atoms in the structure, or `undefined` if no structure
	 * is currently loaded
	 *
	 * @return the number of atoms in the currently loaded structure
	 */
	natoms(): number | undefined;
	/**
	 * Load the given `structure` in this viewer.
	 *
	 * @param structure structure to load
	 * @param options options for the new structure
	 */
	load(structure: Structure, options?: Partial<LoadOptions>): void;
	/** Setup interaction (click & hover) for environments highlighting */
	private _setEnvironmentInteractions;
	/**
	 * Highlight a given `atom` in the current structure.
	 *
	 * If a supercell larger than [1, 1, 1] is currently displayed, this
	 * function accept indexes larger than the result of `natoms()`, and will
	 * then highlight atoms outside of the central image.
	 *
	 * @param center index of the central atom in the environment to show,
	 *               or `undefined` to disable highlighting.
	 */
	highlight(center?: number): void;
	/**
	 * Applies saved settings, possibly filling in with default values
	 */
	applySettings(settings: Settings): void;
	/**
	 * Save the values of the current settings in a way that an be used with
	 * {@link applySettings} or saved to JSON.
	 */
	saveSettings(): Settings;
	/**
	 * Add the given `callback` to be called whenever a setting changes. The
	 * callback will be given the path to the settings as a list of keys; and
	 * the new value of the setting.
	 *
	 * There is currently no way to remove a callback.
	 */
	onSettingChange(callback: (keys: string[], value: unknown) => void): void;
	/**
	 * Returns a PNG screenshot of the viewer as a URI string
	 */
	exportPNG(): string;
	_setHoverable(active: number[]): void;
	private _connectOptions;
	/**
	 * Function called whenever the user click on an atom in the viewer
	 */
	private _selectAtom;
	/**
	 * Update the styles of all atoms as required
	 */
	private _updateStyle;
	/**
	 * Get the main style used for all atoms/atoms inside the environment when
	 * highlighting a specific environment
	 */
	private _mainStyle;
	/**
	 * Get the style specification for the hidden/background atoms when
	 * highlighting a specific environment
	 */
	private _hiddenStyle;
	/**
	 * Get the style specification for the central atom when
	 * highlighting a specific environment
	 */
	private _centralStyle;
	/**
	 * Show the information related to supercell in a small box on the bottom
	 * right corner.
	 */
	private _showSupercellInfo;
	/**
	 * Check whether environments are enabled or not
	 */
	private _environmentsEnabled;
	/**
	 * Enable (if `show` is true) or disable (if `show` is false) the settings
	 * related to environments
	 */
	private _enableEnvironmentSettings;
	/**
	 * Get the cutoff for the environment around the given `center`
	 */
	private _cutoffAround;
	/**
	 * Change which central atom is highlighted in the system to `center`. If
	 * `center` is undefined, this disable highlighting.
	 *
	 * @param center index of the atom to highlight
	 */
	private _changeHighlighted;
	/**
	 * Reset the view by re-centering it and zooming to fit the model as much as
	 * possible inside the views.
	 */
	private _resetView;
	/**
	 * Centers the view around the selected atom (if there is one)
	 */
	private _centerView;
	/**
	 * Rotate the viewed group so that the given direction (in group
	 * coordinates) is aligned with the z axis (in camera space)
	 *
	 * @param direction axis to align with the camera view
	 */
	private _viewAlong;
	/**
	 * Add a labeled arrow of the given color from 0 to the given position, with
	 * the given label.
	 */
	private _addLabeledArrow;
}
/**
 * Welcome to Chemiscope's API documentation
 *
 * The default visualization is organized around four panels: the
 * {@link MetadataPanel|metadata} panel; the {@link PropertiesMap|map} (a scatter plot of
 * properties), the {@link ViewersGrid|structure viewer}, and the general
 * dataset {@link EnvironmentInfo|information}. Each one of these is defined in a
 * separate module.
 *
 * Other organization of the visualization are possible by using the classes
 * responsible for each sub-panel separately, instead of using the
 * {@link DefaultVisualizer}. In this case, developers should make sure to finish
 * the plumbing by setting the right callbacks on each element used.
 *
 * @packageDocumentation
 * @module main
 * @preferred
 */
/**
 * Configuration for the {@link DefaultVisualizer}
 */
export interface DefaultConfig {
	/** Id of the DOM element to use to display metadata */
	meta: string | HTMLElement;
	/** Id of the DOM element to use for the properties map */
	map: string | HTMLElement;
	/** Id of the DOM element to use for the environment information */
	info: string | HTMLElement;
	/** Id of the DOM element to use for the structure viewer grid */
	structure: string | HTMLElement;
	/** Custom structure loading callback, used to set {@link ViewersGrid.loadStructure} */
	loadStructure?: (index: number, structure: unknown) => Structure;
	/** Maximum number of structure viewers allowed in {@link ViewersGrid} */
	maxStructureViewers?: number;
}
/**
 * The default visualization state of chemiscope: three panels (map, structure,
 * info) updating one another when the user interact with any of them.
 */
export declare class DefaultVisualizer {
	/**
	 * Load a dataset and create a visualizer.
	 *
	 * This function returns a `Promise<DefaultVisualizer>` to prevent blocking
	 * the browser while everything is loading.
	 *
	 * @param  config  configuration of the visualizer
	 * @param  dataset visualizer input, containing a dataset and optional visualization settings
	 * @return         Promise that resolves to a {@link DefaultVisualizer}
	 */
	static load(config: DefaultConfig, dataset: Dataset): Promise<DefaultVisualizer>;
	map: PropertiesMap;
	info: EnvironmentInfo;
	meta: MetadataPanel;
	structure: ViewersGrid;
	private _indexer;
	private _dataset;
	private _pinned;
	private constructor();
	/**
	 * Removes all the chemiscope widgets from the DOM
	 */
	remove(): void;
	/**
	 * Get the current values of settings for all panels in the visualizer
	 *
	 * @return the viewers settings, suitable to be used with {@link applySettings}
	 */
	saveSettings(): Settings;
	/**
	 * Apply the given settings to all panels in the visualizer
	 *
	 * @param settings settings for all panels
	 */
	applySettings(settings: Partial<Settings>): void;
	/**
	 * Add the given `callback` to be called whenever a setting changes. The
	 * callback will be given the path to the settings as a list of keys; and
	 * the new value of the setting.
	 *
	 * There is currently no way to remove a callback.
	 */
	onSettingChange(callback: (keys: string[], value: unknown) => void): void;
	/**
	 * Get the dataset used to create the current visualization
	 *
	 * If the dataset is using user-specified structures and a loading callback
	 * {@link DefaultConfig.loadStructure}; you can request all structure to be fully
	 * resolved and placed inside the dataset.
	 *
	 * @param  getStructures should all {@link UserStructure} resolved and placed
	 *                       inside the dataset?
	 * @return the dataset currently visualized
	 */
	dataset(getStructures?: boolean): Dataset;
}
/**
 * Configuration for the {@link StructureVisualizer}
 */
export interface StructureConfig {
	/** Id of the DOM element to use to display metadata */
	meta: string | HTMLElement;
	/** Id of the DOM element to use for the environment information */
	info: string | HTMLElement;
	/** Id of the DOM element to use for the structure viewer grid */
	structure: string | HTMLElement;
	/** Custom structure loading callback, used to set {@link ViewersGrid.loadStructure} */
	loadStructure?: (index: number, structure: unknown) => Structure;
}
/**
 * A structure-only chemiscope visualizer: two panels (map,
 * info) updating one another when the user interact with any of them.
 */
export declare class StructureVisualizer {
	/**
	 * Load a dataset and create a visualizer.
	 *
	 * This function returns a `Promise<StructureVisualizer>` to prevent blocking
	 * the browser while everything is loading.
	 *
	 * @param  config  configuration of the visualizer
	 * @param  dataset visualizer input, containing a dataset and optional visualization settings
	 * @return         Promise that resolves to a {@link StructureVisualizer}
	 */
	static load(config: StructureConfig, dataset: Dataset): Promise<StructureVisualizer>;
	info: EnvironmentInfo;
	meta: MetadataPanel;
	structure: ViewersGrid;
	private _indexer;
	private constructor();
	/**
	 * Removes all the chemiscope widgets from the DOM
	 */
	remove(): void;
	/**
	 * Apply the given `settings` to the structure panels in the visualizer
	 */
	applySettings(settings: Partial<Settings>): void;
	/**
	 * Get the current values of settings for all panels in the visualizer
	 */
	saveSettings(): Settings;
	/**
	 * Add the given `callback` to be called whenever a setting changes. The
	 * callback will be given the path to the settings as a list of keys; and
	 * the new value of the setting.
	 *
	 * There is currently no way to remove a callback.
	 */
	onSettingChange(callback: (keys: string[], value: unknown) => void): void;
}
/**
 * Configuration for the {@link StructureVisualizer}
 */
export interface MapConfig {
	/** Id of the DOM element to use to display metadata */
	meta: string | HTMLElement;
	/** Id of the DOM element to use for the properties map */
	map: string | HTMLElement;
	/** Id of the DOM element to use for the environment information */
	info: string | HTMLElement;
}
/**
 * A map-only visualizer state of chemiscope
 */
export declare class MapVisualizer {
	/**
	 * Load a dataset and create a visualizer.
	 *
	 * This function returns a `Promise<MapVisualizer>` to prevent blocking
	 * the browser while everything is loading.
	 *
	 * @param  config  configuration of the visualizer
	 * @param  dataset visualizer input, containing a dataset and optional visualization settings
	 * @return         Promise that resolves to a {@link MapVisualizer}
	 */
	static load(config: MapConfig, dataset: Dataset): Promise<MapVisualizer>;
	info: EnvironmentInfo;
	map: PropertiesMap;
	meta: MetadataPanel;
	private _indexer;
	private constructor();
	/**
	 * Removes all the chemiscope widgets from the DOM
	 */
	remove(): void;
	/**
	 * Get the current values of settings for all panels in the visualizer
	 */
	saveSettings(): Settings;
	/**
	 * Apply the given `settings` to the structure panels in the visualizer
	 */
	applySettings(settings: Partial<Settings>): void;
	/**
	 * Add the given `callback` to be called whenever a setting changes. The
	 * callback will be given the path to the settings as a list of keys; and
	 * the new value of the setting.
	 *
	 * There is currently no way to remove a callback.
	 */
	onSettingChange(callback: (keys: string[], value: unknown) => void): void;
}
/** Get the version of chemiscope as a string */
export declare function version(): string;

export {};
