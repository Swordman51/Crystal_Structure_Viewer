// Generated by dts-bundle-generator v7.2.0

/** Callback type to position an HTML element.
 *
 * The callback gets the current placement of the settings as a
 * [DOMRect](https://developer.mozilla.org/en-US/docs/Web/API/DOMRect), and
 * should return top and left positions in pixels, used with `position:
 * fixed`.
 */
export type PositioningCallback = (rect: DOMRect) => {
	top: number;
	left: number;
};
/**
 * Type definition for settings that can be saved with a dataset. THey should be
 * a simple object with string keys, scalar values, array values or nested
 * Settings objects.
 */
export interface Settings extends Record<string, string | string[] | number | number[] | boolean | boolean[] | Settings | Settings[]> {
}
/** A single atomic structure */
export interface Structure {
	/** Number of atoms in the structure */
	size: number;
	/** Names of all atoms in the structure */
	names: string[];
	/**
	 * x position (cartesian coordinate) of all atoms in the structure
	 *
	 * This array should have the same size as {@link Structure.names}, and contain
	 * values expressed in Angströms.
	 */
	x: number[];
	/**
	 * y position (cartesian coordinate) of all atoms in the structure
	 *
	 * This array should have the same size as {@link Structure.names}, and contain
	 * values expressed in Angströms.
	 */
	y: number[];
	/**
	 * z position (cartesian coordinate) of all atoms in the structure
	 *
	 * This array should have the same size as {@link Structure.names}, and contain
	 * values expressed in Angströms.
	 */
	z: number[];
	/**
	 * Unit cell of the system, given as `[ax ay az bx by bz cx cy cz]`, where
	 * **a**, **b**, and **c** are the unit cell vectors. All values should be
	 * expressed in Angströms.
	 */
	cell?: number[];
}
/**
 * An atom-centered environment.
 *
 * Currently, only spherical (i.e. cutoff-based) environments are supported
 */
export interface Environment {
	/** Index of the related structure in {@link Dataset.structures} */
	structure: number;
	/** Index of the central atom in the structure, 0-based */
	center: number;
	/** Spherical cutoff radius, expressed in Angströms */
	cutoff: number;
}
declare class Modal {
	private _element;
	private _activeElement;
	private _backdrop;
	private _open;
	shadow: ShadowRoot;
	/**
	 * Create a Modal instance.
	 * @param _element The root element to use as a modal. It should have the
	 *  .modal class.
	 */
	constructor(_element: HTMLElement);
	close(): void;
	open(): void;
	toggle(value?: boolean): void;
	remove(): void;
}
/**
 * Possible HTML attributes to attach to a setting
 */
export type Attribute = "value" | "checked" | "innerText";
export interface OptionsTypeMap {
	string: [
		string
	];
	int: [
		number
	];
	number: [
		number
	];
	boolean: [
		boolean
	];
}
export type OptionsType = keyof OptionsTypeMap;
export type OptionsValue<T extends OptionsType> = OptionsTypeMap[T][0];
/** Possible origins of a option change: from JS code, or from DOM interaction */
export type OptionModificationOrigin = "JS" | "DOM";
declare class HTMLOption<T extends OptionsType> {
	/** the type of the value stored by this setting */
	readonly type: T;
	/** Callback to validate the new value before propagating changes. */
	validate: (value: OptionsValue<T>) => void;
	/** Additional callbacks to run whenever the setting value changes */
	onchange: Array<(value: OptionsValue<T>, origin: OptionModificationOrigin) => void>;
	private _value;
	private _boundList;
	private _previous_value;
	/**
	 * Create a new {@link HTMLOption} containing a value of the given type.
	 * Possible type/values combinations are described in the {@link OptionsTypeMap}
	 * interface.
	 *
	 * @param type  type of the setting
	 * @param value initial value of the setting
	 */
	constructor(type: T, value: OptionsValue<T>);
	/** Get the value of this setting */
	get value(): OptionsValue<T>;
	/** Set a new value for this setting */
	set value(v: OptionsValue<T>);
	/**
	 * Call all onchange callbacks & update the DOM representation after a
	 * change. This function is called automatically when using `.value = ...`
	 */
	changed(origin: OptionModificationOrigin): void;
	/** Reset to a previous value for this setting */
	reset(): void;
	/**
	 * Add a new HTML element to the list of synchronized element.
	 * `element.attribute` will be set to the setting value, and the setting
	 * value will be updated every time the 'change' event is sent.
	 *
	 * @param  element   HTML DOM element to watch for updates, or string id
	 *                   of such element
	 * @param  attribute attribute of the HTML element to use as value
	 */
	bind(element: HTMLElement | string, attribute: Attribute): void;
	/**
	 * Disable all HTML elements linked to this by setting the `disabled`
	 * attribute to `true` if it exists on the element. This should only
	 * disable HTMLInputElement.
	 */
	disable(): void;
	/**
	 * Enable all HTML elements linked to this by setting the `disabled`
	 * attribute to `false` if it exists on the element. This should only
	 * enable HTMLInputElement.
	 */
	enable(): void;
	/**
	 * Remove all HTML elements bound to this setting, and the associated event
	 * listeners.
	 */
	unbindAll(): void;
	private _update;
}
/**
 * Callback function to use with {@link OptionsGroup.foreachSetting}
 */
export type OptionsCallback = (keys: string[], setting: HTMLOption<any>) => void;
declare abstract class OptionsGroup {
	/**
	 * Save the current values of all HTMLOption properties of the class,
	 * including nested ones.
	 *
	 * Properties which name starts with an underscore are ignored.
	 *
	 * @return An object with the same structure as this class containing the
	 *         values of all settings.
	 */
	saveSettings(): Settings;
	/**
	 * Set values from `settings` to the {@link HTMLOption} properties of this class,
	 * matching the properties names.
	 *
	 * Properties starting with an underscore are ignored.
	 */
	applySettings(settings: Settings): void;
	/**
	 * Add the given `callback` to be called whenever a setting changes. The
	 * callback will be given the path to the settings as a list of keys; and
	 * the new value of the setting.
	 *
	 * There is currently no way to remove a callback.
	 */
	onSettingChange(callback: (keys: string[], value: unknown) => void): void;
	/**
	 * Call the given callback on each setting inside the given SettingGroup.
	 *
	 * Keys starting with an underscore character are ignored.
	 *
	 * @param settings group of settings
	 * @param callback callback operating on a single setting
	 */
	protected foreachOption(callback: OptionsCallback): void;
}
declare class StructureOptions extends OptionsGroup {
	bonds: HTMLOption<"boolean">;
	spaceFilling: HTMLOption<"boolean">;
	atomLabels: HTMLOption<"boolean">;
	unitCell: HTMLOption<"boolean">;
	supercell: [
		HTMLOption<"int">,
		HTMLOption<"int">,
		HTMLOption<"int">
	];
	rotation: HTMLOption<"boolean">;
	axes: HTMLOption<"string">;
	keepOrientation: HTMLOption<"boolean">;
	playbackDelay: HTMLOption<"number">;
	environments: {
		activated: HTMLOption<"boolean">;
		center: HTMLOption<"boolean">;
		cutoff: HTMLOption<"number">;
		bgStyle: HTMLOption<"string">;
		bgColor: HTMLOption<"string">;
	};
	private _modal;
	private _openModal;
	private _positionSettingsModal;
	constructor(root: HTMLElement, positionSettings: PositioningCallback);
	/** Get in a element in the modal from its id */
	getModalElement<T extends HTMLElement = HTMLElement>(id: string): T;
	/** Get the modal used for these settings */
	get modal(): Modal;
	/**
	 * Remove all HTML added by this {@link StructureSettings} in the current
	 * document
	 */
	remove(): void;
	/**
	 * Applies saved settings, possibly filling in with default values
	 */
	applySettings(settings: Settings): void;
	/**
	 * Create HTML needed for structure settings.
	 *
	 * The HTML elements are returned, not yet inserted in the document.
	 *
	 * @return the HTML element containing the setting modal, and the button to open the modal
	 */
	private _createSettingsHTML;
	/** Bind all options to the corresponding HTML elements */
	private _bind;
}
/** Possible options passed to `MoleculeViewer.load` */
export interface LoadOptions {
	/** Supercell to display (default: [1, 1, 1]) */
	supercell: [
		number,
		number,
		number
	];
	/** Should preserve we the current camera orientation (default: false) */
	keepOrientation: boolean;
	/** Are we loading a file part of a trajectory (default: false) */
	trajectory: boolean;
	/** List of atom-centered environments in the current structure, potentially
	 * undefined if the environnement is not part of the dataset.
	 * The `structure` field of `Environment` is ignored */
	environments: (Environment | undefined)[];
	/**
	 * Index of the environment to highlight, this is only considered if
	 * `environments` is set.
	 */
	highlight: number;
}
/** */
export declare class MoleculeViewer {
	/** callback called when a new atom is clicked on */
	onselect: (atom: number) => void;
	/**
	 * Callback to get the initial positioning of the settings modal.
	 *
	 * The callback is called once, the first time the settings are opened.
	 */
	positionSettingsModal: PositioningCallback;
	private _shadow;
	private _root;
	private _viewer;
	private _current?;
	private _highlighted?;
	private _axes?;
	_options: StructureOptions;
	private _initialSupercell?;
	private _resetEnvCutoff;
	private _resetSupercell;
	private _cellInfo;
	private _trajectoryOptions;
	private _styles;
	private _environments?;
	/**
	 * Create a new `MoleculeViewer` inside the HTML DOM element with the given `id`.
	 *
	 * @param element HTML element or HTML id of the DOM element
	 *                where the viewer will be created
	 */
	constructor(element: string | HTMLElement);
	/**
	 * Remove all HTML added by this {@link MoleculeViewer} in the current document
	 */
	remove(): void;
	/**
	 * Resize the 3Dmol viewer/canvas to the size of the HTML element containing
	 * this widget.
	 */
	resize(): void;
	/**
	 * Get the number of atoms in the structure, or `undefined` if no structure
	 * is currently loaded
	 *
	 * @return the number of atoms in the currently loaded structure
	 */
	natoms(): number | undefined;
	/**
	 * Load the given `structure` in this viewer.
	 *
	 * @param structure structure to load
	 * @param options options for the new structure
	 */
	load(structure: Structure, options?: Partial<LoadOptions>): void;
	/** Setup interaction (click & hover) for environments highlighting */
	private _setEnvironmentInteractions;
	/**
	 * Highlight a given `atom` in the current structure.
	 *
	 * If a supercell larger than [1, 1, 1] is currently displayed, this
	 * function accept indexes larger than the result of `natoms()`, and will
	 * then highlight atoms outside of the central image.
	 *
	 * @param center index of the central atom in the environment to show,
	 *               or `undefined` to disable highlighting.
	 */
	highlight(center?: number): void;
	/**
	 * Applies saved settings, possibly filling in with default values
	 */
	applySettings(settings: Settings): void;
	/**
	 * Save the values of the current settings in a way that an be used with
	 * {@link applySettings} or saved to JSON.
	 */
	saveSettings(): Settings;
	/**
	 * Add the given `callback` to be called whenever a setting changes. The
	 * callback will be given the path to the settings as a list of keys; and
	 * the new value of the setting.
	 *
	 * There is currently no way to remove a callback.
	 */
	onSettingChange(callback: (keys: string[], value: unknown) => void): void;
	/**
	 * Returns a PNG screenshot of the viewer as a URI string
	 */
	exportPNG(): string;
	_setHoverable(active: number[]): void;
	private _connectOptions;
	/**
	 * Function called whenever the user click on an atom in the viewer
	 */
	private _selectAtom;
	/**
	 * Update the styles of all atoms as required
	 */
	private _updateStyle;
	/**
	 * Get the main style used for all atoms/atoms inside the environment when
	 * highlighting a specific environment
	 */
	private _mainStyle;
	/**
	 * Get the style specification for the hidden/background atoms when
	 * highlighting a specific environment
	 */
	private _hiddenStyle;
	/**
	 * Get the style specification for the central atom when
	 * highlighting a specific environment
	 */
	private _centralStyle;
	/**
	 * Show the information related to supercell in a small box on the bottom
	 * right corner.
	 */
	private _showSupercellInfo;
	/**
	 * Check whether environments are enabled or not
	 */
	private _environmentsEnabled;
	/**
	 * Enable (if `show` is true) or disable (if `show` is false) the settings
	 * related to environments
	 */
	private _enableEnvironmentSettings;
	/**
	 * Get the cutoff for the environment around the given `center`
	 */
	private _cutoffAround;
	/**
	 * Change which central atom is highlighted in the system to `center`. If
	 * `center` is undefined, this disable highlighting.
	 *
	 * @param center index of the atom to highlight
	 */
	private _changeHighlighted;
	/**
	 * Reset the view by re-centering it and zooming to fit the model as much as
	 * possible inside the views.
	 */
	private _resetView;
	/**
	 * Centers the view around the selected atom (if there is one)
	 */
	private _centerView;
	/**
	 * Rotate the viewed group so that the given direction (in group
	 * coordinates) is aligned with the z axis (in camera space)
	 *
	 * @param direction axis to align with the camera view
	 */
	private _viewAlong;
	/**
	 * Add a labeled arrow of the given color from 0 to the given position, with
	 * the given label.
	 */
	private _addLabeledArrow;
}

export {};
